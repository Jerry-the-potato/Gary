# role: SA - ç³»çµ±æ¶æ§‹èˆ‡æŠ€è¡“è¦æ ¼è£œå……åˆ†æ

## æ ¸å¿ƒå»ºè­°

### 1. **API ä»‹é¢è¦æ ¼è¨­è¨ˆ**
**ğŸ”— å®Œæ•´çš„å‰å¾Œç«¯æ•¸æ“šäº¤æ›æ¨™æº–**

```typescript
// API ä»‹é¢è¦æ ¼å®šç¾©
interface AlgorithmAPISpec {
  // æ¼”ç®—æ³•åŸ·è¡Œè«‹æ±‚
  executeRequest: {
    method: 'POST',
    endpoint: '/api/v1/algorithm/execute',
    body: {
      algorithmType: 'bubble-sort' | 'quick-sort' | 'merge-sort' | 'heap-sort',
      inputData: number[],
      executionMode: 'step-by-step' | 'batch' | 'real-time',
      options?: {
        maxSteps?: number,
        stepDelay?: number,
        visualizationLevel?: 'basic' | 'detailed' | 'debug'
      }
    }
  },

  // æ¼”ç®—æ³•æ­¥é©Ÿå›æ‡‰
  executeResponse: {
    success: boolean,
    data: {
      sessionId: string,
      totalSteps: number,
      initialState: AlgorithmState,
      metadata: {
        timeComplexity: string,
        spaceComplexity: string,
        expectedOperations: number
      }
    },
    error?: {
      code: string,
      message: string,
      details: any
    }
  }
}

// æ¼”ç®—æ³•ç‹€æ…‹è³‡æ–™çµæ§‹
interface AlgorithmState {
  stepIndex: number,
  arrayData: number[],
  highlightedIndices: number[],
  comparisonPair?: [number, number],
  swapPair?: [number, number],
  pivotIndex?: number,
  sortedRange?: {
    start: number,
    end: number
  },
  operation: {
    type: 'compare' | 'swap' | 'move' | 'merge' | 'complete',
    description: string,
    elements: number[],
    metrics: {
      comparisons: number,
      swaps: number,
      arrayAccess: number
    }
  }
}

// WebSocket å³æ™‚æ›´æ–°è¦æ ¼
interface RealtimeUpdateSpec {
  connection: 'ws://localhost:5000/api/v1/algorithm/realtime',
  messageTypes: {
    // å®¢æˆ¶ç«¯è¨Šæ¯
    startExecution: {
      type: 'START_EXECUTION',
      payload: {
        algorithmType: string,
        inputData: number[],
        speed: number
      }
    },

    pauseExecution: {
      type: 'PAUSE_EXECUTION',
      payload: { sessionId: string }
    },

    // ä¼ºæœå™¨è¨Šæ¯
    stepUpdate: {
      type: 'STEP_UPDATE',
      payload: AlgorithmState
    },

    executionComplete: {
      type: 'EXECUTION_COMPLETE',
      payload: {
        sessionId: string,
        finalMetrics: PerformanceMetrics,
        executionTime: number
      }
    }
  }
}
```

### 2. **WebGPU é™ç´šç­–ç•¥æ¶æ§‹**
**ğŸ”„ å¤šå±¤æ¬¡æ¸²æŸ“å¼•æ“è¨­è¨ˆ**

```typescript
// æ¸²æŸ“å¼•æ“æŠ½è±¡å±¤
abstract class RenderingEngine {
  abstract initialize(canvas: HTMLCanvasElement): Promise<boolean>
  abstract renderFrame(frameData: FrameData): void
  abstract updateUIElements(uiState: UIState): void
  abstract destroy(): void

  // å…±åŒä»‹é¢
  public abstract get isHardwareAccelerated(): boolean
  public abstract get maxArraySize(): number
  public abstract get supportedFeatures(): RenderingFeatures
}

// WebGPU å¯¦ä½œ
class WebGPURenderingEngine extends RenderingEngine {
  private device: GPUDevice
  private context: GPUCanvasContext
  private renderPipeline: GPURenderPipeline

  async initialize(canvas: HTMLCanvasElement): Promise<boolean> {
    try {
      if (!navigator.gpu) return false

      const adapter = await navigator.gpu.requestAdapter()
      if (!adapter) return false

      this.device = await adapter.requestDevice()
      this.context = canvas.getContext('webgpu')!

      await this.createRenderPipeline()
      return true

    } catch (error) {
      console.warn('WebGPU initialization failed:', error)
      return false
    }
  }

  get isHardwareAccelerated(): boolean { return true }
  get maxArraySize(): number { return 10000 }
  get supportedFeatures(): RenderingFeatures {
    return {
      hardware3D: true,
      complexShaders: true,
      largeTextures: true,
      computeShaders: true
    }
  }
}

// Canvas2D é™ç´šå¯¦ä½œ
class Canvas2DRenderingEngine extends RenderingEngine {
  private context: CanvasRenderingContext2D
  private animationFrame: number = 0

  async initialize(canvas: HTMLCanvasElement): Promise<boolean> {
    const ctx = canvas.getContext('2d')
    if (!ctx) return false

    this.context = ctx
    return true
  }

  renderFrame(frameData: FrameData): void {
    this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height)

    // ç¹ªè£½é™£åˆ—å…ƒç´ ï¼ˆç°¡åŒ–ç‰ˆï¼‰
    frameData.arrayData.forEach((value, index) => {
      const x = index * (this.context.canvas.width / frameData.arrayData.length)
      const height = (value / Math.max(...frameData.arrayData)) * this.context.canvas.height * 0.8

      // æ ¹æ“šç‹€æ…‹é¸æ“‡é¡è‰²
      this.context.fillStyle = this.getElementColor(index, frameData.highlightedIndices)
      this.context.fillRect(x, this.context.canvas.height - height, 20, height)
    })
  }

  get isHardwareAccelerated(): boolean { return false }
  get maxArraySize(): number { return 1000 }
  get supportedFeatures(): RenderingFeatures {
    return {
      hardware3D: false,
      complexShaders: false,
      largeTextures: false,
      computeShaders: false
    }
  }
}

// è‡ªå‹•é™ç´šç®¡ç†å™¨
class RenderingEngineManager {
  private currentEngine: RenderingEngine

  async initializeBestEngine(canvas: HTMLCanvasElement): Promise<RenderingEngine> {
    // å„ªå…ˆå˜—è©¦ WebGPU
    const webgpuEngine = new WebGPURenderingEngine()
    if (await webgpuEngine.initialize(canvas)) {
      console.log('Using WebGPU rendering engine')
      this.currentEngine = webgpuEngine
      return webgpuEngine
    }

    // é™ç´šåˆ° Canvas2D
    const canvas2dEngine = new Canvas2DRenderingEngine()
    if (await canvas2dEngine.initialize(canvas)) {
      console.log('Fallback to Canvas2D rendering engine')
      this.currentEngine = canvas2dEngine
      return canvas2dEngine
    }

    throw new Error('No rendering engine available')
  }

  getCurrentEngine(): RenderingEngine {
    return this.currentEngine
  }
}
```

### 3. **è¨˜æ†¶é«”ç®¡ç†ç­–ç•¥**
**ğŸ’¾ å¤§å‹æ•¸æ“šé›†è™•ç†èˆ‡å„ªåŒ–æ–¹æ¡ˆ**

```typescript
// è¨˜æ†¶é«”ç®¡ç†æ¶æ§‹
class MemoryManager {
  private maxHeapSize = 512 * 1024 * 1024 // 512MB é™åˆ¶
  private dataPool = new Map<string, ArrayBuffer>()
  private gcThreshold = 0.8 // 80% ä½¿ç”¨ç‡è§¸ç™¼æ¸…ç†

  // æ•¸æ“šåˆ†ç‰‡è™•ç†
  processLargeDataset(data: number[]): ProcessedDataChunks {
    const chunkSize = this.calculateOptimalChunkSize(data.length)
    const chunks: DataChunk[] = []

    for (let i = 0; i < data.length; i += chunkSize) {
      const chunk = data.slice(i, i + chunkSize)
      chunks.push({
        id: `chunk_${i}`,
        data: new Int32Array(chunk),
        startIndex: i,
        endIndex: Math.min(i + chunkSize, data.length),
        isLoaded: false
      })
    }

    return { chunks, totalSize: data.length }
  }

  private calculateOptimalChunkSize(totalSize: number): number {
    // æ ¹æ“šå¯ç”¨è¨˜æ†¶é«”å‹•æ…‹èª¿æ•´åˆ†ç‰‡å¤§å°
    const availableMemory = this.getAvailableMemory()
    const elementSize = 4 // Int32 = 4 bytes

    if (totalSize * elementSize < availableMemory * 0.1) {
      return totalSize // å°æ•¸æ“šé›†ï¼Œä¸åˆ†ç‰‡
    }

    return Math.floor(availableMemory * 0.05 / elementSize) // 5% è¨˜æ†¶é«”åˆ†ç‰‡
  }

  // è™›æ“¬åŒ–æ¸²æŸ“
  virtualizeRendering(visibleRange: [number, number], allData: number[]): VirtualizedData {
    const [start, end] = visibleRange
    const bufferSize = Math.floor((end - start) * 0.2) // 20% ç·©è¡å€

    const virtualStart = Math.max(0, start - bufferSize)
    const virtualEnd = Math.min(allData.length, end + bufferSize)

    return {
      visibleData: allData.slice(virtualStart, virtualEnd),
      offsetIndex: virtualStart,
      totalLength: allData.length,
      viewportSize: end - start
    }
  }

  // è¨˜æ†¶é«”ä½¿ç”¨ç›£æ§
  monitorMemoryUsage(): MemoryReport {
    const usage = (performance as any).memory

    return {
      usedJSHeapSize: usage?.usedJSHeapSize || 0,
      totalJSHeapSize: usage?.totalJSHeapSize || 0,
      jsHeapSizeLimit: usage?.jsHeapSizeLimit || 0,
      usagePercentage: usage ? (usage.usedJSHeapSize / usage.jsHeapSizeLimit) * 100 : 0,
      recommendsGC: usage ? (usage.usedJSHeapSize / usage.jsHeapSizeLimit) > this.gcThreshold : false
    }
  }
}

// æ•¸æ“šè™•ç†æµæ°´ç·š
class DataProcessingPipeline {
  private memoryManager = new MemoryManager()
  private workerPool: Worker[] = []

  constructor() {
    this.initializeWorkerPool()
  }

  async processAlgorithmData(
    algorithmType: string,
    inputData: number[]
  ): Promise<ProcessingResult> {

    // æª¢æŸ¥æ•¸æ“šå¤§å°ï¼Œæ±ºå®šè™•ç†ç­–ç•¥
    if (inputData.length > 5000) {
      return this.processLargeDataset(algorithmType, inputData)
    } else {
      return this.processSmallDataset(algorithmType, inputData)
    }
  }

  private async processLargeDataset(
    algorithmType: string,
    inputData: number[]
  ): Promise<ProcessingResult> {

    // åˆ†ç‰‡è™•ç†
    const chunks = this.memoryManager.processLargeDataset(inputData)
    const results: AlgorithmStep[] = []

    // ä½¿ç”¨ Web Workers ä¸¦è¡Œè™•ç†
    const workerPromises = chunks.chunks.map((chunk, index) => {
      const worker = this.workerPool[index % this.workerPool.length]

      return new Promise<AlgorithmStep[]>((resolve, reject) => {
        worker.postMessage({
          type: 'PROCESS_CHUNK',
          algorithmType,
          chunkData: chunk.data,
          chunkIndex: index
        })

        worker.onmessage = (event) => {
          if (event.data.type === 'CHUNK_RESULT') {
            resolve(event.data.steps)
          }
        }

        worker.onerror = reject
      })
    })

    const chunkResults = await Promise.all(workerPromises)

    // åˆä½µçµæœ
    return this.mergeChunkResults(chunkResults)
  }

  private initializeWorkerPool() {
    const workerCount = Math.min(navigator.hardwareConcurrency || 4, 4)

    for (let i = 0; i < workerCount; i++) {
      const worker = new Worker('/workers/algorithm-worker.js')
      this.workerPool.push(worker)
    }
  }
}
```

## è¼¸å‡ºç”¢ç‰©

### 1. **ç³»çµ±æ¶æ§‹åœ–**
```mermaid
graph TB
    subgraph "å‰ç«¯å±¤"
        A[Vue 3 æ‡‰ç”¨] --> B[Composition API]
        B --> C[Pinia ç‹€æ…‹ç®¡ç†]
        C --> D[æ¸²æŸ“å¼•æ“ç®¡ç†å™¨]

        D --> E[WebGPU å¼•æ“]
        D --> F[Canvas2D å¼•æ“]

        E --> G[GPU ç·©è¡å€ç®¡ç†]
        F --> H[2D æ¸²æŸ“æœ€ä½³åŒ–]
    end

    subgraph "é€šè¨Šå±¤"
        I[HTTP API å®¢æˆ¶ç«¯]
        J[WebSocket å®¢æˆ¶ç«¯]
        K[Worker æ± ]
    end

    subgraph "å¾Œç«¯å±¤"
        L[.NET Core API]
        M[æ¼”ç®—æ³•æœå‹™]
        N[WebSocket Hub]
        O[Redis å¿«å–]
        P[PostgreSQL]
    end

    A --> I
    A --> J
    B --> K

    I --> L
    J --> N
    L --> M
    L --> O
    M --> P
```

### 2. **æŠ€è¡“æ±ºç­–çŸ©é™£**
```typescript
// æŠ€è¡“é¸å‹æ±ºç­–è¡¨
interface TechnicalDecisionMatrix {
  rendering: {
    primary: {
      technology: 'WebGPU',
      reasons: [
        'ç¡¬é«”åŠ é€Ÿæ¸²æŸ“',
        'æ”¯æ´å¤§å‹æ•¸æ“šé›†',
        'è¤‡é›œè‘—è‰²å™¨æ•ˆæœ',
        'æœªä¾†æ“´å±•æ€§'
      ],
      risks: [
        'ç€è¦½å™¨æ”¯æ´åº¦',
        'é–‹ç™¼è¤‡é›œåº¦',
        'é™¤éŒ¯å›°é›£'
      ]
    },

    fallback: {
      technology: 'Canvas2D',
      reasons: [
        'å»£æ³›ç€è¦½å™¨æ”¯æ´',
        'é–‹ç™¼ç°¡å–®',
        'ç©©å®šå¯é '
      ],
      limitations: [
        'æ•ˆèƒ½é™åˆ¶',
        'åŠŸèƒ½å—é™',
        'å¤§æ•¸æ“šé›†å›°é›£'
      ]
    }
  },

  dataProcessing: {
    clientSide: {
      technology: 'Rust WASM + Web Workers',
      benefits: [
        'è¿‘åŸç”Ÿæ•ˆèƒ½',
        'ä¸¦è¡Œè™•ç†',
        'è¨˜æ†¶é«”å®‰å…¨'
      ]
    },

    serverSide: {
      technology: '.NET Core + C#',
      benefits: [
        'æˆç†Ÿç”Ÿæ…‹ç³»',
        'å¼·å‹åˆ¥',
        'å„ªç§€é™¤éŒ¯å·¥å…·'
      ]
    }
  }
}
```

### 3. **æ•ˆèƒ½ç›£æ§ç³»çµ±**
```typescript
// ç³»çµ±æ•ˆèƒ½ç›£æ§
class PerformanceMonitor {
  private metrics = new Map<string, PerformanceMetric>()
  private reportInterval = 5000 // 5ç§’å ±å‘Šé–“éš”

  startMonitoring() {
    setInterval(() => {
      this.collectMetrics()
      this.analyzePerformance()
      this.reportToBackend()
    }, this.reportInterval)
  }

  private collectMetrics() {
    // æ¸²æŸ“æ•ˆèƒ½
    this.metrics.set('fps', {
      value: this.calculateFPS(),
      timestamp: Date.now(),
      threshold: { min: 50, optimal: 60 }
    })

    // è¨˜æ†¶é«”ä½¿ç”¨
    const memoryInfo = (performance as any).memory
    this.metrics.set('memory', {
      value: memoryInfo?.usedJSHeapSize || 0,
      timestamp: Date.now(),
      threshold: { max: 100 * 1024 * 1024 } // 100MB
    })

    // æ¼”ç®—æ³•åŸ·è¡Œæ™‚é–“
    this.metrics.set('algorithm_execution', {
      value: this.getLastExecutionTime(),
      timestamp: Date.now(),
      threshold: { max: 1000 } // 1ç§’
    })
  }

  private analyzePerformance(): PerformanceAnalysis {
    const analysis = {
      overall: 'good',
      issues: [] as string[],
      recommendations: [] as string[]
    }

    // FPS åˆ†æ
    const fps = this.metrics.get('fps')
    if (fps && fps.value < 50) {
      analysis.overall = 'poor'
      analysis.issues.push('ä½ FPS æ•ˆèƒ½')
      analysis.recommendations.push('è€ƒæ…®é™ç´šåˆ° Canvas2D')
    }

    // è¨˜æ†¶é«”åˆ†æ
    const memory = this.metrics.get('memory')
    if (memory && memory.value > 100 * 1024 * 1024) {
      analysis.issues.push('è¨˜æ†¶é«”ä½¿ç”¨éé«˜')
      analysis.recommendations.push('å•Ÿç”¨æ•¸æ“šè™›æ“¬åŒ–')
    }

    return analysis
  }
}
```

## ä¸‹ä¸€æ­¥è¡Œå‹•

### ç«‹å³åŸ·è¡Œï¼ˆæœ¬é€±ï¼‰ï¼š
1. **API è¦æ ¼å¯¦ä½œ**ï¼šèˆ‡å¾Œç«¯ Gary å”ä½œå®Œæˆ API ç«¯é»é–‹ç™¼
2. **é™ç´šæ©Ÿåˆ¶æ¸¬è©¦**ï¼šåœ¨ä¸æ”¯æ´ WebGPU çš„ç’°å¢ƒä¸­æ¸¬è©¦ Canvas2D é™ç´š
3. **è¨˜æ†¶é«”ç®¡ç†å™¨å¯¦ä½œ**ï¼šå»ºç«‹åŸºç¤çš„è¨˜æ†¶é«”ç›£æ§èˆ‡ç®¡ç†ç³»çµ±

### çŸ­æœŸè¦åŠƒï¼ˆ2 é€±å…§ï¼‰ï¼š
1. **æ•ˆèƒ½åŸºæº–æ¸¬è©¦**ï¼šå»ºç«‹å„ç¨®æ•¸æ“šè¦æ¨¡ä¸‹çš„æ•ˆèƒ½åŸºæº–
2. **Worker æ± æœ€ä½³åŒ–**ï¼šå¯¦ä½œä¸¦è¡Œæ•¸æ“šè™•ç†ç³»çµ±
3. **ç›£æ§ç³»çµ±æ•´åˆ**ï¼šå°‡æ•ˆèƒ½ç›£æ§æ•´åˆåˆ°ç¾æœ‰ç³»çµ±ä¸­

### ä¸­æœŸç›®æ¨™ï¼ˆ1 å€‹æœˆå…§ï¼‰ï¼š
1. **è² è¼‰æ¸¬è©¦**ï¼šé€²è¡Œå¤§å‹æ•¸æ“šé›†çš„å£“åŠ›æ¸¬è©¦
2. **è·¨ç€è¦½å™¨ç›¸å®¹æ€§**ï¼šç¢ºä¿æ‰€æœ‰ä¸»æµç€è¦½å™¨çš„ç©©å®šé‹è¡Œ
3. **ç³»çµ±æ–‡ä»¶å®Œå–„**ï¼šå»ºç«‹å®Œæ•´çš„æŠ€è¡“æ–‡ä»¶èˆ‡ API èªªæ˜

## å”ä½œæé†’

### ğŸ¤ éœ€è¦ BE Gary å”ä½œï¼š
- **API ç«¯é»å¯¦ä½œ**ï¼šæ ¹æ“šæä¾›çš„è¦æ ¼å¯¦ä½œå¾Œç«¯ API
- **WebSocket æ•´åˆ**ï¼šå»ºç«‹å³æ™‚æ•¸æ“šæ¨é€æ©Ÿåˆ¶
- **æ•ˆèƒ½è³‡æ–™æ”¶é›†**ï¼šå¾Œç«¯æ”¶é›†èˆ‡åˆ†æå‰ç«¯æ•ˆèƒ½è³‡æ–™

### ğŸ¤ éœ€è¦ FE Jerry ç¢ºèªï¼š
- **é™ç´šç­–ç•¥å¯¦ä½œ**ï¼šCanvas2D é™ç´šç‰ˆæœ¬çš„åŠŸèƒ½ç¯„åœ
- **è¨˜æ†¶é«”ç®¡ç†æ•´åˆ**ï¼šè¨˜æ†¶é«”ç®¡ç†å™¨èˆ‡ç¾æœ‰ Composition API çš„æ•´åˆæ–¹å¼
- **Worker é€šè¨Šå”å®š**ï¼šå‰ç«¯èˆ‡ Web Worker çš„è³‡æ–™äº¤æ›æ ¼å¼

### ğŸ’¡ å»ºè­°å„ªå…ˆç´šï¼š
**P0ï¼ˆå¿…é ˆï¼‰ï¼š** API è¦æ ¼ + åŸºç¤é™ç´šæ©Ÿåˆ¶
**P1ï¼ˆé‡è¦ï¼‰ï¼š** è¨˜æ†¶é«”ç®¡ç† + æ•ˆèƒ½ç›£æ§
**P2ï¼ˆåŠ åˆ†ï¼‰ï¼š** ä¸¦è¡Œè™•ç† + é€²éšæœ€ä½³åŒ–

**ç¸½çµ**ï¼šæä¾›äº†å®Œæ•´çš„ç³»çµ±æ¶æ§‹è¦æ ¼ï¼Œæ¶µè“‹ API è¨­è¨ˆã€é™ç´šç­–ç•¥èˆ‡è¨˜æ†¶é«”ç®¡ç†ã€‚é€™äº›è¦æ ¼ç¢ºä¿ç³»çµ±åœ¨å„ç¨®ç’°å¢ƒä¸‹éƒ½èƒ½ç©©å®šé‹è¡Œï¼ŒåŒæ™‚ç‚ºæœªä¾†æ“´å±•å¥ å®šè‰¯å¥½åŸºç¤ã€‚
